{"version":3,"sources":["webpack:///./src/pages/GameOfLifePage/Cell.jsx","webpack:///./src/types/exports.js","webpack:///./src/hooks/useUniverse.jsx"],"names":["Cell","props","classes","row","col","state","universeDispatch","className","undefined","CELL_TYPES","ALIVE","aliveCell","deadCell","onClick","type","ACTIONS","FLIP","DEAD","DELIMETER","convertToKey","isCellAlive","keyString","liveSet","has","checkNeighbor","neighborString","numAliveNeighbors","checkSet","add","checkAllNeighbors","numRow","numCol","arr","split","parseInt","left","right","top","bottom","getNeighborPositions","createUniverse","newUniverse","universeRow","push","initialize","spawnRate","Set","Math","random","universe","LIVE_SET","reducer","action","length","delete","Error","useUniverse","isPaused","useReducer","dispatch","useState","generation","setGeneration","useEffect","interval","setInterval","newLiveSet","forEach","clearInterval","universeState"],"mappings":"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","file":"component---src-pages-game-of-life-page-cell-jsx-2eb74699f454c37217b0.js","sourcesContent":["/**\n * @flow\n */\n\nimport React from \"react\";\nimport { makeStyles } from \"@material-ui/styles\";\n\nimport { ACTIONS } from \"hooks/useUniverse.jsx\";\nimport { CELL_TYPES } from \"types/exports\";\n\ntype PropType = {\n    row: Number,\n    col: Number,\n    state: CELL_TYPES,\n    universeDispatch: Object,\n};\n\n// const useStyles = makeStyles(theme => ({\n//     aliveCell: {\n//         width: theme.cellSize,\n//         height: theme.cellSize,\n//         borderStyle: \"dotted\",\n//         borderColor: \"black\",\n//         backgroundColor: theme.aliveColor,\n//     },\n//     deadCell: {\n//         width: theme.cellSize,\n//         height: theme.cellSize,\n//         borderStyle: \"dotted\",\n//         borderColor: \"black\",\n//         backgroundColor: theme.deadColor,\n//     },\n// }));\n\nfunction Cell(props: PropType) {\n    const { classes, row, col, state, universeDispatch } = props;\n    let className = \"\";\n    if (classes !== undefined) {\n        className =\n            state === CELL_TYPES.ALIVE ? classes.aliveCell : classes.deadCell;\n    }\n    //const classes = useStyles();\n    return (\n        <button\n            className={className}\n            onClick={() =>\n                universeDispatch({\n                    type: ACTIONS.FLIP,\n                    row: row,\n                    col: col,\n                })\n            }\n        ></button>\n    );\n}\n\nexport default Cell;\n","export const CELL_SIZE = 50;\n\nexport const CELL_TYPES = {\n    DEAD: false,\n    ALIVE: true,\n};\n\nexport const BOARD_STATE = {\n    ODD: 0,\n    EVEN: 1,\n}\n\n","/**\n * @flow\n */\nimport { useState, useEffect, useReducer } from \"react\";\nimport { CELL_TYPES } from \"types/exports\";\n\ntype LiveSet = Set<String>;\ntype Position = {\n    row: number,\n    col: number,\n};\n\nconst DELIMETER = \",\";\n\nfunction convertToKey(row: number, col: number): String {\n    return row + DELIMETER + col;\n}\n\nfunction convertToPosition(key: String): Position {\n    const arr = key.split(DELIMETER);\n    return { row: parseInt(arr[0]), col: parseInt(arr[1]) };\n}\n\nfunction isCellAlive(keyString: string, liveSet: Set<String>): Boolean {\n    return liveSet.has(keyString);\n}\n\nfunction getNeighborPositions(\n    row: number,\n    col: number,\n    numRow: number,\n    numCol: number\n) {\n    const left = col - 1 >= 0 ? col - 1 : numCol - 1;\n    const right = col + 1 < numCol ? col + 1 : 0;\n    const top = row - 1 >= 0 ? row - 1 : numRow - 1;\n    const bottom = row + 1 < numRow ? row + 1 : 0;\n\n    return { left, right, top, bottom };\n}\n\n/**\n * Checks to see if the passed in neighbor is alive\n * If so, returns numAliveNeighbors + 1\n *\n * Has side effect of adding the cell to the checkSet if it isn't alive\n * @param {String} neighborString\n * @param {number} numAliveNeighbors\n * @param {Set<String>} liveSet\n * @param {Set<String>} checkSet\n */\nfunction checkNeighbor(\n    neighborString: String,\n    numAliveNeighbors: number,\n    liveSet: LiveSet,\n    checkSet: LiveSet\n): number {\n    if (isCellAlive(neighborString, liveSet)) {\n        return numAliveNeighbors + 1;\n    } else {\n        if (checkSet !== null) checkSet.add(neighborString);\n        return numAliveNeighbors;\n    }\n}\n\n/**\n *\n * @param {*} keyString\n * @param {*} liveSet\n * @param {*} checkSet\n * @param {*} numRow\n * @param {*} numCol\n */\nfunction checkAllNeighbors(\n    keyString: String,\n    liveSet: LiveSet,\n    checkSet: LiveSet,\n    numRow: number,\n    numCol: number\n): number {\n    const { row, col } = convertToPosition(keyString);\n    const { left, right, top, bottom } = getNeighborPositions(\n        row,\n        col,\n        numRow,\n        numCol\n    );\n    // left, right correspond to col\n    // top, bottom correspond to row\n\n    let numAliveNeighbors = 0;\n\n    // Top Left\n    const topLeftString = convertToKey(top, left);\n    numAliveNeighbors = checkNeighbor(\n        topLeftString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Top\n    const topString = convertToKey(top, col);\n    numAliveNeighbors = checkNeighbor(\n        topString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Top Right\n    const topRightString = convertToKey(top, right);\n    numAliveNeighbors = checkNeighbor(\n        topRightString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Right\n    const rightString = convertToKey(row, right);\n    numAliveNeighbors = checkNeighbor(\n        rightString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Bottom Right\n    const bottomRightString = convertToKey(bottom, right);\n    numAliveNeighbors = checkNeighbor(\n        bottomRightString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Bottom\n    const bottomString = convertToKey(bottom, col);\n    numAliveNeighbors = checkNeighbor(\n        bottomString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Bottom Left\n    const bottomLeftString = convertToKey(bottom, left);\n    numAliveNeighbors = checkNeighbor(\n        bottomLeftString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    // Left\n    const leftString = convertToKey(row, left);\n    numAliveNeighbors = checkNeighbor(\n        leftString,\n        numAliveNeighbors,\n        liveSet,\n        checkSet\n    );\n\n    return numAliveNeighbors;\n}\n\nfunction createUniverse(numRow, numCol, liveSet) {\n    const newUniverse = [];\n    for (let row = 0; row < numRow; row++) {\n        const universeRow = [];\n        for (let col = 0; col < numCol; col++) {\n            const keyString = convertToKey(row, col);\n            if (isCellAlive(keyString, liveSet)) {\n                universeRow.push(CELL_TYPES.ALIVE);\n            } else {\n                universeRow.push(CELL_TYPES.DEAD);\n            }\n        }\n        newUniverse.push(universeRow);\n    }\n    return newUniverse;\n}\n\nfunction initialize({ numRow, numCol, spawnRate }) {\n    const liveSet = new Set();\n    for (let row = 0; row < numRow; row++) {\n        for (let col = 0; col < numCol; col++) {\n            if (Math.random() < spawnRate) {\n                const keyString = convertToKey(row, col);\n                liveSet.add(keyString);\n            }\n        }\n    }\n    const universe = createUniverse(numRow, numCol, liveSet);\n    return { liveSet: liveSet, universe: universe };\n}\n\nexport const ACTIONS = {\n    LIVE_SET: 0,\n    FLIP: 1,\n};\n\nfunction reducer(state, action) {\n    let { liveSet, universe } = state;\n\n    switch (action.type) {\n        case ACTIONS.LIVE_SET:\n            liveSet = action.liveSet;\n            const numRow = universe.length;\n            const numCol = universe[0].length;\n            universe = createUniverse(numRow, numCol, liveSet);\n            break;\n        case ACTIONS.FLIP:\n            const { row, col } = action;\n            const keyString = convertToKey(row, col);\n            if (isCellAlive(keyString, state.liveSet)) {\n                liveSet.delete();\n                universe[row][col] = CELL_TYPES.DEAD;\n            } else {\n                liveSet.add(keyString);\n                universe[row][col] = CELL_TYPES.ALIVE;\n            }\n\n            break;\n        default:\n            throw new Error(\"Invalid action provided\");\n    }\n\n    return {\n        liveSet: liveSet,\n        universe: universe,\n    };\n}\n\nexport function useUniverse(\n    numRow: number,\n    numCol: number,\n    spawnRate: number,\n    isPaused\n) {\n    const [state, dispatch] = useReducer(\n        reducer,\n        { numRow, numCol, spawnRate },\n        initialize\n    );\n    const [generation, setGeneration] = useState(0);\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            if (isPaused) return;\n\n            const newLiveSet = new Set();\n            const checkSet = new Set();\n\n            state.liveSet.forEach(keyString => {\n                const numAliveNeighbors = checkAllNeighbors(\n                    keyString,\n                    state.liveSet,\n                    checkSet,\n                    numRow,\n                    numCol\n                );\n                if (numAliveNeighbors === 2 || numAliveNeighbors === 3) {\n                    newLiveSet.add(keyString);\n                }\n            });\n\n            checkSet.forEach(keyString => {\n                const numAliveNeighbors = checkAllNeighbors(\n                    keyString,\n                    state.liveSet,\n                    null,\n                    numRow,\n                    numCol\n                );\n                if (numAliveNeighbors === 3) {\n                    newLiveSet.add(keyString);\n                }\n            });\n\n            dispatch({ type: ACTIONS.LIVE_SET, liveSet: newLiveSet });\n            setGeneration(generation => generation + 1);\n        }, 1000);\n\n        return () => clearInterval(interval);\n    }, [isPaused, state.liveSet, numRow, numCol]);\n\n    return {\n        generation: generation,\n        universeState: state,\n        universeDispatch: dispatch,\n    };\n}\n"],"sourceRoot":""}